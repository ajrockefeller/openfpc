#!/usr/bin/perl -I .

#########################################################################################
# Copyright (C) 2010 Leon Ward 
# openfpc-queued.pl - Part of the OpenFPC - (Full Packet Capture) project
#
# Contact: leon@rm-rf.co.uk
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either version 2
# of the License, or (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#########################################################################################

use strict;
use warnings;
use threads;
use threads::shared;
use Thread::Queue;
use IO::Socket;
#use Digest::MD5(qw(md5_hex));
use Getopt::Long;
use POSIX qw(setsid);		# Required for daemon mode
use Data::Dumper;
use File::Temp(qw(tempdir));
#use DBI;

use OFPC::Config;
use OFPC::Common;
use OFPC::Parse;
use OFPC::Request;
use OFPC::CXDB;

=head1 NAME
	openfpc-queued - Queue and process extract requests from local and remote PCAP storage devices
=head1 VERSION 

0.333

=cut
my ($queuelen,$rid,$help);

my %pcaps: shared =();
my %route: shared =();
my $configfile=0;
my $daemon=0;		# NOT DONE YET
$verbose=0;
sub showhelp{
	print <<EOF

   * openfpc-queued *
   Part of the OpenFPC project.

   --daemon  or -d		Daemon mode
   --config  or -c <file>	Config file  
   --help    or -h		Show help
   --verbose or -v		Verbose logging
   --debug  	 		Show debug data
  
EOF
}

=head2 pipeHandler
	Deal with clients that disappear rather than have perl die.
=cut

sub pipeHandler{
    my $sig = shift @_;
    print "SIGPIPE -> Bad client went away! $sig \n\n" if ($verbose);
}





=head frageq
	Take a single request, and re-insert it in the queue but for every known device.
	This isn't used right now, I was testing some concepts out.

sub fragreq{
	print "Fraging request\n";

	my $request=shift;
	foreach my $device (keys %route){
		$request->{'rid'} = OFPC::Common::getrequestid;
		$request->{'device'} = $device;
        	my $qlen=$queue->pending();     # Length of extract queue
		print "Qlen is $qlen\n";
		# Inject a a sub-request to node that exists
		print "Adding sub-request RID $request->{'rid'} to $request->{'device'} \n";
		$queue->enqueue($request);
        	$qlen=$queue->pending();     # Length of extract queue
		print "Qlen is $qlen\n";
	}
	# If original req is WAITING, report back it's fraged so it can move on.
}
# That was disabled for now
=cut

=head2 runq
	Runq waits for an entry to appear in the extraction queue, and then takes action on it.
=cut

sub runq {
	while (1) {
        	sleep(1);                       # Pause between polls of queue
        	my $qlen=$queue->pending();     # Length of extract queue
        	if ($qlen >= 1) {
			my $request=$queue->dequeue();
                	wlog("RUNQ : Found request: $request->{'rid'} Queue length: $qlen");
                	wlog("RUNQ : Request: $request->{'rid'} User: $request->{'user'} Found in queue:");
			if ($config{'PROXY'}) {

				(my $nodehost,my $nodeport,my $nodeuser,my $nodepass)=routereq($request->{'device'});

				if ($nodehost) { 		# If this request is routable....
					$request->{'nodehost'} = $nodehost;
					$request->{'nodeuser'} = $nodeuser;
					$request->{'nodeport'} = $nodeport;
					$request->{'nodepass'} = $nodepass;

                			wlog("RUNQ : PROXY: Request: $request->{'rid'} Routable");    
					my $result=doproxy($request);
                			wlog("RUNQ : PROXY: Request: $request->{'rid'} Result: $result->{'success'} Message: $result->{'message'}");    
					if ($result->{'success'} ) {
						$pcaps{$request->{'rid'}}=$request->{'filename'} ; # Report done
					} else {
						$pcaps{$request->{'rid'}}="ERROR" ; # Report FAIL 
					}
				} else {
					wlog("RUNQ : No openfpc-route to $request->{'device'}. Cant extract.");
					$pcaps{$request->{'rid'}}="NOROUTE"; # Report FAIL 
				}
			} else {
				my $result = donode($request,$rid);
				if ($result->{'success'}) {
                			wlog("RUNQ : NODE: Request: $request->{'rid'} Success. File: $result->{'filename'} $result->{'size'} now cached on NODE in $config{'SAVEDIR'}"); 
					$pcaps{$request->{'rid'}}=$result->{'filename'};
				} else {
                			wlog("RUNQ: NODE: Request: $request->{'rid'} Result: Failed, $result->{'message'}.");    
				}
			}
        	}
	}
}

########### Start Here  ############
$SIG{PIPE} = \&pipeHandler;

$SIG{"TERM"}  = sub { closedown("TERM") };
$SIG{"KILL"}  = sub { closedown("KILL") };

GetOptions (
	'c|conf=s' => \$configfile,
	'd|daemon' => \$daemon,
	'h|help' => \$help,
	'debug' => \$debug,
	'v|verbose' => \$verbose,
	'vdebug' => \$vdebug,
        );

if ($debug) { 
	$verbose=1;
	wlog("DEBUG Enabled\n");
}

if ($vdebug) {
	$verbose=1;
	$debug=1;
	wlog("VDEBUG Enabled\n");
}

if ($help) { 
	showhelp();
	exit;
}

OFPC::Common::initlog or die("Problem initilizating log subsystem");
OFPC::Config::readconfig("$configfile") or die("Problem processing config file $configfile");

wlog("*********** OpenFPC $openfpcver **********");
wlog("**    http://www.openfpc.org    **");

if ($config{'PROXY'}) {
        wlog("CONF: Starting OFPC Node \"$config{'NODENAME'}\" as an OpenFPC Proxy");
	
} else {
        wlog("CONF: Starting OFPC Node \"$config{'NODENAME'}\" as an OpenFPC Node");
}

# Print verbose config info if debug is enabled
if ($debug) {
	wlog("CONF: Node Description: $config{'DESCRIPTION'}");
	wlog("CONF: Enabled : $config{'OFPC_ENABLED'}");
	wlog("CONF: local savedir : $config{'SAVEDIR'}");
	wlog("CONF: Buffer Path : $config{'BUFFER_PATH'}");
	wlog("CONF: mergecap : $config{'MERGECAP'}");
	wlog("CONF: tcpdump : $config{'TCPDUMP'}");
	wlog("CONF: Keep files : $config{'KEEPFILES'}");
}

# Start listener
wlog("MAIN: Starting listener on TCP:$config{'OFPC_PORT'}\n") if ($debug);
my $listenSocket = IO::Socket::INET->new(
                                LocalPort => $config{'OFPC_PORT'},
                                Proto => 'tcp',
                                Listen => '10',
                                Reuse => 1,
                                );

unless ($listenSocket) { 
	wlog("Problem creating socke on $config{'OFPC_PORT'}"); 
	exit 1;
}
$listenSocket->autoflush(1);

if ($daemon) {
	chdir '/' or die "Can't chdir to /: $!";
	umask 0;
	open STDIN, '/dev/null'   or die "Can't read /dev/null: $!";
	open (STDOUT, "> $config{'LOGFILE'}") or die "Can't open Log for STDOUT  $config{'LOGFILE'}: $!\n";
	defined(my $pid = fork)   or die "Can't fork: $!";
	if ($pid) {
		open (PID, "> $config{'PIDPATH'}/openfpc-queued-$config{'NODENAME'}.pid") or die "Unable write to pid file $config{'PIDPATH'}/openfpc-queued-$config{'NODENAME'}.pid: $!\n";
      		print PID $pid, "\n";
      		close (PID);
		exit 0;
	}
	# Redirect STDERR Last to catch any error in the fork() process.
	open (STDERR, "> $config{'LOGFILE'}") or die "Can't open Log for STDERR $config{'LOGFILE'}: $!\n";
	setsid or die "Can't start a new session: $!";
}

threads->create("runq");
threads->create("OFPC::Common::backgroundtasks");

while (my $sock = $listenSocket->accept) {
	# set client socket to non blocking
	my $nonblocking = 1;
	ioctl($sock, 0x8004667e, \\$nonblocking);
	$sock->autoflush(1);
	my $client_ip=$sock->peerhost;
	wlog("COMMS: Accepted new connection from $client_ip") ;

	# start new thread and listen on the socket
	threads->create("OFPC::Common::comms", $sock);
}
